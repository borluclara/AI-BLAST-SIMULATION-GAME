{"ast":null,"code":"class Physics {\n  constructor() {\n    this.restitution = 0.7; // Bounce factor\n  }\n  handleBoundaryCollision(particle, width, height) {\n    // Left and right boundaries\n    if (particle.x - particle.size < 0) {\n      particle.x = particle.size;\n      particle.vx *= -this.restitution;\n    } else if (particle.x + particle.size > width) {\n      particle.x = width - particle.size;\n      particle.vx *= -this.restitution;\n    }\n\n    // Top and bottom boundaries\n    if (particle.y - particle.size < 0) {\n      particle.y = particle.size;\n      particle.vy *= -this.restitution;\n    } else if (particle.y + particle.size > height) {\n      particle.y = height - particle.size;\n      particle.vy *= -this.restitution;\n\n      // Add some friction when hitting the ground\n      particle.vx *= 0.9;\n    }\n  }\n  checkParticleCollision(particle1, particle2) {\n    const dx = particle2.x - particle1.x;\n    const dy = particle2.y - particle1.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    const minDistance = particle1.size + particle2.size;\n    if (distance < minDistance) {\n      // Collision detected\n      const overlap = minDistance - distance;\n      const separation = overlap / 2;\n\n      // Separate particles\n      const separationX = dx / distance * separation;\n      const separationY = dy / distance * separation;\n      particle1.x -= separationX;\n      particle1.y -= separationY;\n      particle2.x += separationX;\n      particle2.y += separationY;\n\n      // Calculate collision response\n      const relativeVelocityX = particle2.vx - particle1.vx;\n      const relativeVelocityY = particle2.vy - particle1.vy;\n      const speed = Math.sqrt(relativeVelocityX * relativeVelocityX + relativeVelocityY * relativeVelocityY);\n      if (speed > 0.1) {\n        const normalX = dx / distance;\n        const normalY = dy / distance;\n        const impactSpeed = relativeVelocityX * normalX + relativeVelocityY * normalY;\n        if (impactSpeed > 0) {\n          const impulse = 2 * impactSpeed / (particle1.mass + particle2.mass);\n          particle1.vx += impulse * particle2.mass * normalX * this.restitution;\n          particle1.vy += impulse * particle2.mass * normalY * this.restitution;\n          particle2.vx -= impulse * particle1.mass * normalX * this.restitution;\n          particle2.vy -= impulse * particle1.mass * normalY * this.restitution;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  applyForce(particle, forceX, forceY) {\n    particle.vx += forceX / particle.mass;\n    particle.vy += forceY / particle.mass;\n  }\n  calculateDistance(x1, y1, x2, y2) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  normalizeVector(x, y) {\n    const length = Math.sqrt(x * x + y * y);\n    if (length === 0) return {\n      x: 0,\n      y: 0\n    };\n    return {\n      x: x / length,\n      y: y / length\n    };\n  }\n}\nexport default Physics;","map":{"version":3,"names":["Physics","constructor","restitution","handleBoundaryCollision","particle","width","height","x","size","vx","y","vy","checkParticleCollision","particle1","particle2","dx","dy","distance","Math","sqrt","minDistance","overlap","separation","separationX","separationY","relativeVelocityX","relativeVelocityY","speed","normalX","normalY","impactSpeed","impulse","mass","applyForce","forceX","forceY","calculateDistance","x1","y1","x2","y2","normalizeVector","length"],"sources":["C:/Users/THEO COMPUTERS/Desktop/AI-BLAST-SIMULATION-GAME/src/utils/Physics.js"],"sourcesContent":["class Physics {\r\n  constructor() {\r\n    this.restitution = 0.7; // Bounce factor\r\n  }\r\n\r\n  handleBoundaryCollision(particle, width, height) {\r\n    // Left and right boundaries\r\n    if (particle.x - particle.size < 0) {\r\n      particle.x = particle.size;\r\n      particle.vx *= -this.restitution;\r\n    } else if (particle.x + particle.size > width) {\r\n      particle.x = width - particle.size;\r\n      particle.vx *= -this.restitution;\r\n    }\r\n\r\n    // Top and bottom boundaries\r\n    if (particle.y - particle.size < 0) {\r\n      particle.y = particle.size;\r\n      particle.vy *= -this.restitution;\r\n    } else if (particle.y + particle.size > height) {\r\n      particle.y = height - particle.size;\r\n      particle.vy *= -this.restitution;\r\n      \r\n      // Add some friction when hitting the ground\r\n      particle.vx *= 0.9;\r\n    }\r\n  }\r\n\r\n  checkParticleCollision(particle1, particle2) {\r\n    const dx = particle2.x - particle1.x;\r\n    const dy = particle2.y - particle1.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    const minDistance = particle1.size + particle2.size;\r\n\r\n    if (distance < minDistance) {\r\n      // Collision detected\r\n      const overlap = minDistance - distance;\r\n      const separation = overlap / 2;\r\n\r\n      // Separate particles\r\n      const separationX = (dx / distance) * separation;\r\n      const separationY = (dy / distance) * separation;\r\n\r\n      particle1.x -= separationX;\r\n      particle1.y -= separationY;\r\n      particle2.x += separationX;\r\n      particle2.y += separationY;\r\n\r\n      // Calculate collision response\r\n      const relativeVelocityX = particle2.vx - particle1.vx;\r\n      const relativeVelocityY = particle2.vy - particle1.vy;\r\n\r\n      const speed = Math.sqrt(relativeVelocityX * relativeVelocityX + relativeVelocityY * relativeVelocityY);\r\n      \r\n      if (speed > 0.1) {\r\n        const normalX = dx / distance;\r\n        const normalY = dy / distance;\r\n\r\n        const impactSpeed = relativeVelocityX * normalX + relativeVelocityY * normalY;\r\n\r\n        if (impactSpeed > 0) {\r\n          const impulse = 2 * impactSpeed / (particle1.mass + particle2.mass);\r\n\r\n          particle1.vx += impulse * particle2.mass * normalX * this.restitution;\r\n          particle1.vy += impulse * particle2.mass * normalY * this.restitution;\r\n          particle2.vx -= impulse * particle1.mass * normalX * this.restitution;\r\n          particle2.vy -= impulse * particle1.mass * normalY * this.restitution;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  applyForce(particle, forceX, forceY) {\r\n    particle.vx += forceX / particle.mass;\r\n    particle.vy += forceY / particle.mass;\r\n  }\r\n\r\n  calculateDistance(x1, y1, x2, y2) {\r\n    const dx = x2 - x1;\r\n    const dy = y2 - y1;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  normalizeVector(x, y) {\r\n    const length = Math.sqrt(x * x + y * y);\r\n    if (length === 0) return { x: 0, y: 0 };\r\n    return { x: x / length, y: y / length };\r\n  }\r\n}\r\n\r\nexport default Physics;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}